from interface.ai_service_pb2_grpc import AiService
from interface.ai_service_pb2 import AutoGeneratedResponse,AutoData,ManualGeneratedResponse,AnalyticPostsResponse,AnalyticData
from core import LoggerService, PromptBuilder, Generator
import models
import uuid
from pydantic import ValidationError

class AiService(AiService):
    async def AutoGeneratedPosts(self, request, context):

        def return_data(code:int,detail:str, content:list[AutoData] = []):
            return AutoGeneratedResponse(
                status_code = code,
                detail = detail,
                data = content,
            )

        operation_uuid = uuid.uuid4()

        data = {
                    "posts":[{"id": p.id, "content": p.content, "posted_at":p.posted_at} for p in request.posts],
                    "prompts":request.prompts,
                    "prompt_base":request.prompt_base,
                    "tone_of_voice":request.tone_of_voice,
                    "words_count":request.words_count,
                    "use_emoji":request.use_emoji,
                    "use_hashtag":request.use_hashtag,
                    "lang":request.lang,
                }

        try:
            models.AutoGeneratedRequestModel(**data)
        except ValidationError as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)
                
            return return_data(400,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')

        LoggerService.debug(f'proc-id: {operation_uuid}|core.ai_service.AutoGeneratedPosts|Data received:{len(data.get('posts'))}{[pst.get('id') for pst in data.get('posts')]}')

        prompt_builder = PromptBuilder(data.get('lang'),'generation',5)
        data.pop('lang')

        try:
            prompts:list[str] = prompt_builder.auto_prompt(**data)
        except Exception as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)
            
            return return_data(500,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')

        LoggerService.debug(f'proc-id: {operation_uuid}|core.ai_service.AutoGeneratedPosts| Get prompts: {len(prompts)}')

        generation = Generator(operation_uuid)

        try:
            generated_text = await generation.start(prompts,10)
        except Exception as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)

            return return_data(500,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')

        data_objects = []
        id_for_dbg=[]


        for objects in [item for sublist in generated_text for item in sublist]:
            

            if (not objects.get('parent_id')) or (not objects.get('content')) or (not objects.get('posted_at')):
                continue

            data_objects.append(AutoData(parent_id=int(objects.get('parent_id')), content=str(objects.get('content')),scheduled_at=objects.get('posted_at')))
            id_for_dbg.append(objects.get('parent_id'))

        LoggerService.debug(f'proc-id: {operation_uuid}|core.ai_service.AutoGeneratedPosts|Generated posts:{len(id_for_dbg)}{id_for_dbg}')


        return return_data(200,'ok',data_objects)
    
    async def ManualGeneratedPosts(self, request, context):
        def return_data(code:int,detail:str, content:str = ''):
            return ManualGeneratedResponse(
                status_code = code,
                detail = detail,
                data = content,
            )
        
        operation_uuid = uuid.uuid4()

        data = {
                "prompt":request.prompt,
                "lang":request.lang,
            }

        try:
            models.ManualGeneratedRequestModel(**data)
        except ValidationError as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)
                
            return return_data(400,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')
        
        LoggerService.debug(f'proc-id: {operation_uuid}|core.ai_service.ManualGeneratedPosts|Data received:{data}')

        prompt_builder = PromptBuilder(data.get('lang'),'manual',1)

        data.pop('lang')

        try:
            prompt:str = prompt_builder.manual_prompt(**data)
        except Exception as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)

            return return_data(500,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')
        
        LoggerService.debug(f'proc-id: {operation_uuid}|core.ai_service.ManualGeneratedPosts|Prompt receive:{prompt}')

        generation = Generator(operation_uuid)

        try:
            generated_text = await generation.start([prompt])
        except Exception as error:
                LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)

                return return_data(500,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')

        LoggerService.debug(f'proc-id: {operation_uuid}|core.ai_service.ManualGeneratedPosts|Generated post:{generated_text}')

        return return_data(200,'ok',generated_text[0][0].get('content',''))
    
    async def AnalyticPosts(self, request, context):
        
        def return_data(code:int,detail:str, content:list[AnalyticData]=[]):
            return AnalyticPostsResponse(
                status_code = code,
                detail = detail,
                data = content,
            )
        
        operation_uuid = uuid.uuid4()

        data = {
                    "posts":[{
                                "id": p.id,
                                "channel":p.channel,
                                "content": p.content,
                                "posted_at": p.posted_at,
                                "text_urls": p.text_urls,
                                "views": p.views,
                                "forwards": p.forwards,
                                "replies_count": p.replies_count,
                                "total_reactions": p.total_reactions,
                                "stars": p.stars,
                                "reaction": [{"count":r.count , "emoji":r.emoji} for r in p.reaction]
                            } for p in request.posts],
                    "lang":request.lang
                }

        try:
            models.AnalyticPostsRequestModel(**data)
        except ValidationError as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)
            
            return return_data(400,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')
        
        LoggerService.debug(f'proc-id: {operation_uuid}| core.ai_service.AnalyticPosts|Data received:{len(data.get('posts'))}{[pst.get('id') for pst in data.get('posts')]}')
    
        prompt_builder = PromptBuilder(data.get('lang'),'analytic',5)

        try:
            prompts:list[str] = prompt_builder.analytic_prompt(data.get('posts'))
        except Exception as error:
            LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)
            
            return return_data(500,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}')

        LoggerService.debug(f'proc-id: {operation_uuid}| core.ai_service.AnalyticPosts|Prompts received:{len(prompts)}')
        
        generation = Generator(operation_uuid)
        
        try:
            analytic:list[dict[str,any]] = await generation.start(prompts,30)
        except Exception as error:
                LoggerService.error(f'proc-id: {operation_uuid}|{type(error).__name__}',exc=error)
                
                return return_data(500,f'proc-id: {operation_uuid}|{type(error).__name__}:{error}',)
        
        flat_data = [item for sublist in analytic for item in sublist]

        LoggerService.debug(f'proc-id: {operation_uuid}| core.ai_service.AnalyticPosts|Posts that have passed analytics verification:{len(flat_data)}{[d.get('post_id') for d in flat_data]}')

        data_object = [AnalyticData(post_id=d.get('post_id'),post_channel=d.get('post_channel'),er_score=d.get('er_score'),sentiment_score=d.get('sentiment_score'),final_score=d.get('final_score'),posted_at = d.get('posted_at')) for d in flat_data]

        return return_data(200,'ok',data_object)
